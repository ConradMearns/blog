/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/.pnpm/p-defer@1.0.0/node_modules/p-defer/index.js
var require_p_defer = __commonJS({
  "node_modules/.pnpm/p-defer@1.0.0/node_modules/p-defer/index.js"(exports, module2) {
    "use strict";
    module2.exports = () => {
      const ret = {};
      ret.promise = new Promise((resolve, reject) => {
        ret.resolve = resolve;
        ret.reject = reject;
      });
      return ret;
    };
  }
});

// node_modules/.pnpm/map-age-cleaner@0.2.0/node_modules/map-age-cleaner/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/map-age-cleaner@0.2.0/node_modules/map-age-cleaner/dist/index.js"(exports, module2) {
    "use strict";
    var pDefer = require_p_defer();
    function mapAgeCleaner(map, property = "maxAge") {
      let processingKey;
      let processingTimer;
      let processingDeferred;
      const cleanup = async () => {
        if (processingKey !== void 0) {
          return;
        }
        const setupTimer = async (item) => {
          processingDeferred = pDefer();
          const delay = item[1][property] - Date.now();
          if (delay <= 0) {
            map.delete(item[0]);
            processingDeferred.resolve();
            return;
          }
          processingKey = item[0];
          processingTimer = setTimeout(() => {
            map.delete(item[0]);
            if (processingDeferred) {
              processingDeferred.resolve();
            }
          }, delay);
          if (typeof processingTimer.unref === "function") {
            processingTimer.unref();
          }
          return processingDeferred.promise;
        };
        try {
          for (const entry of map) {
            await setupTimer(entry);
          }
        } catch (_a) {
        }
        processingKey = void 0;
      };
      const reset = () => {
        processingKey = void 0;
        if (processingTimer !== void 0) {
          clearTimeout(processingTimer);
          processingTimer = void 0;
        }
        if (processingDeferred !== void 0) {
          processingDeferred.reject(void 0);
          processingDeferred = void 0;
        }
      };
      const originalSet = map.set.bind(map);
      map.set = (key, value) => {
        if (map.has(key)) {
          map.delete(key);
        }
        const result = originalSet(key, value);
        if (processingKey && processingKey === key) {
          reset();
        }
        cleanup();
        return result;
      };
      cleanup();
      return map;
    }
    module2.exports = mapAgeCleaner;
  }
});

// node_modules/.pnpm/expiry-map@2.0.0/node_modules/expiry-map/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/.pnpm/expiry-map@2.0.0/node_modules/expiry-map/dist/index.js"(exports, module2) {
    "use strict";
    var mapAgeCleaner = require_dist();
    var ExpiryMap2 = class {
      constructor(maxAge, data) {
        this.maxAge = maxAge;
        this[Symbol.toStringTag] = "Map";
        this.data = /* @__PURE__ */ new Map();
        mapAgeCleaner(this.data);
        if (data) {
          for (const [key, value] of data) {
            this.set(key, value);
          }
        }
      }
      get size() {
        return this.data.size;
      }
      clear() {
        this.data.clear();
      }
      delete(key) {
        return this.data.delete(key);
      }
      has(key) {
        return this.data.has(key);
      }
      get(key) {
        const value = this.data.get(key);
        if (value) {
          return value.data;
        }
        return;
      }
      set(key, value) {
        this.data.set(key, {
          maxAge: Date.now() + this.maxAge,
          data: value
        });
        return this;
      }
      values() {
        return this.createIterator((item) => item[1].data);
      }
      keys() {
        return this.data.keys();
      }
      entries() {
        return this.createIterator((item) => [item[0], item[1].data]);
      }
      forEach(callbackfn, thisArg) {
        for (const [key, value] of this.entries()) {
          callbackfn.apply(thisArg, [value, key, this]);
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      *createIterator(projection) {
        for (const item of this.data.entries()) {
          yield projection(item);
        }
      }
    };
    module2.exports = ExpiryMap2;
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CanvasConversationPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/chatgpt-api.ts
var import_expiry_map = __toESM(require_dist2());

// node_modules/.pnpm/p-timeout@6.0.0/node_modules/p-timeout/index.js
var TimeoutError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "TimeoutError";
  }
};
var AbortError = class extends Error {
  constructor(message) {
    super();
    this.name = "AbortError";
    this.message = message;
  }
};
var getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError(errorMessage) : new DOMException(errorMessage);
var getAbortedReason = (signal) => {
  const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException(reason);
};
function pTimeout(promise, options) {
  const {
    milliseconds,
    fallback,
    message,
    customTimers = { setTimeout, clearTimeout }
  } = options;
  let timer;
  const cancelablePromise = new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      resolve(promise);
      return;
    }
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason(signal));
      });
    }
    timer = customTimers.setTimeout.call(void 0, () => {
      if (fallback) {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      const errorMessage = typeof message === "string" ? message : `Promise timed out after ${milliseconds} milliseconds`;
      const timeoutError = message instanceof Error ? message : new TimeoutError(errorMessage);
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      reject(timeoutError);
    }, milliseconds);
    (async () => {
      try {
        resolve(await promise);
      } catch (error) {
        reject(error);
      } finally {
        customTimers.clearTimeout.call(void 0, timer);
      }
    })();
  });
  cancelablePromise.clear = () => {
    customTimers.clearTimeout.call(void 0, timer);
    timer = void 0;
  };
  return cancelablePromise;
}

// node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/.pnpm/eventsource-parser@0.0.5/node_modules/eventsource-parser/dist/index.mjs
function createParser(onParse) {
  let isFirstChunk;
  let buffer;
  let startingPosition;
  let startingFieldLength;
  let eventId;
  let eventName;
  let data;
  reset();
  return {
    feed,
    reset
  };
  function reset() {
    isFirstChunk = true;
    buffer = "";
    startingPosition = 0;
    startingFieldLength = -1;
    eventId = void 0;
    eventName = void 0;
    data = "";
  }
  function feed(chunk) {
    buffer = buffer ? buffer + chunk : chunk;
    if (isFirstChunk && hasBom(buffer)) {
      buffer = buffer.slice(BOM.length);
    }
    isFirstChunk = false;
    const length = buffer.length;
    let position = 0;
    let discardTrailingNewline = false;
    while (position < length) {
      if (discardTrailingNewline) {
        if (buffer[position] === "\n") {
          ++position;
        }
        discardTrailingNewline = false;
      }
      let lineLength = -1;
      let fieldLength = startingFieldLength;
      let character;
      for (let index = startingPosition; lineLength < 0 && index < length; ++index) {
        character = buffer[index];
        if (character === ":" && fieldLength < 0) {
          fieldLength = index - position;
        } else if (character === "\r") {
          discardTrailingNewline = true;
          lineLength = index - position;
        } else if (character === "\n") {
          lineLength = index - position;
        }
      }
      if (lineLength < 0) {
        startingPosition = length - position;
        startingFieldLength = fieldLength;
        break;
      } else {
        startingPosition = 0;
        startingFieldLength = -1;
      }
      parseEventStreamLine(buffer, position, fieldLength, lineLength);
      position += lineLength + 1;
    }
    if (position === length) {
      buffer = "";
    } else if (position > 0) {
      buffer = buffer.slice(position);
    }
  }
  function parseEventStreamLine(lineBuffer, index, fieldLength, lineLength) {
    if (lineLength === 0) {
      if (data.length > 0) {
        onParse({
          type: "event",
          id: eventId,
          event: eventName || void 0,
          data: data.slice(0, -1)
        });
        data = "";
        eventId = void 0;
      }
      eventName = void 0;
      return;
    }
    const noValue = fieldLength < 0;
    const field = lineBuffer.slice(index, index + (noValue ? lineLength : fieldLength));
    let step = 0;
    if (noValue) {
      step = lineLength;
    } else if (lineBuffer[index + fieldLength + 1] === " ") {
      step = fieldLength + 2;
    } else {
      step = fieldLength + 1;
    }
    const position = index + step;
    const valueLength = lineLength - step;
    const value = lineBuffer.slice(position, position + valueLength).toString();
    if (field === "data") {
      data += value ? "".concat(value, "\n") : "\n";
    } else if (field === "event") {
      eventName = value;
    } else if (field === "id" && !value.includes("\0")) {
      eventId = value;
    } else if (field === "retry") {
      const retry = parseInt(value, 10);
      if (!Number.isNaN(retry)) {
        onParse({
          type: "reconnect-interval",
          value: retry
        });
      }
    }
  }
}
var BOM = [239, 187, 191];
function hasBom(buffer) {
  return BOM.every((charCode, index) => buffer.charCodeAt(index) === charCode);
}

// src/chatgpt-api.ts
var import_obsidian = require("obsidian");

// src/chatgpt-types.ts
var ChatGPTError = class extends Error {
};

// src/chatgpt-api.ts
async function fetchSSE(options) {
  const { onMessage, ...fetchOptions } = options;
  const res = await (0, import_obsidian.requestUrl)(fetchOptions);
  if (res.status >= 400) {
    const msg = `ChatGPTAPI error ${res.status}`;
    const error = new ChatGPTError(msg);
    error.statusCode = res.status;
    error.statusText = res.text;
    error.response = res;
    throw error;
  }
  const parser = createParser((event) => {
    if (event.type === "event") {
      onMessage(event.data);
    }
  });
  const decoder = new TextDecoder();
  const str = decoder.decode(res.arrayBuffer);
  parser.feed(str);
}
var KEY_ACCESS_TOKEN = "accessToken";
var USER_AGENT = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36";
var AChatGPTAPI = class {
  async resetSession() {
    await this.closeSession();
    return this.initSession();
  }
};
var ChatGPTAPI = class extends AChatGPTAPI {
  constructor(opts) {
    super();
    this._user = null;
    const {
      sessionToken,
      clearanceToken,
      markdown = true,
      apiBaseUrl = "https://chat.openai.com/api",
      backendApiBaseUrl = "https://chat.openai.com/backend-api",
      userAgent = USER_AGENT,
      accessTokenTTL = 60 * 6e4,
      accessToken,
      headers,
      debug = false
    } = opts;
    this._sessionToken = sessionToken;
    this._clearanceToken = clearanceToken;
    this._markdown = !!markdown;
    this._debug = !!debug;
    this._apiBaseUrl = apiBaseUrl;
    this._backendApiBaseUrl = backendApiBaseUrl;
    this._userAgent = userAgent;
    this._headers = {
      "user-agent": this._userAgent,
      "x-openai-assistant-app-id": "",
      "accept-language": "en-US,en;q=0.9",
      "accept-encoding": "gzip, deflate, br",
      origin: "https://chat.openai.com",
      referer: "https://chat.openai.com/chat",
      "sec-ch-ua": '"Not?A_Brand";v="8", "Chromium";v="108", "Google Chrome";v="108"',
      "sec-ch-ua-platform": '"macOS"',
      "sec-fetch-dest": "empty",
      "sec-fetch-mode": "cors",
      "sec-fetch-site": "same-origin",
      ...headers
    };
    this._accessTokenCache = new import_expiry_map.default(accessTokenTTL);
    if (accessToken) {
      this._accessTokenCache.set(KEY_ACCESS_TOKEN, accessToken);
    }
    if (!this._sessionToken) {
      const error = new ChatGPTError("ChatGPT invalid session token");
      error.statusCode = 401;
      throw error;
    }
    if (!this._clearanceToken) {
      const error = new ChatGPTError("ChatGPT invalid clearance token");
      error.statusCode = 401;
      throw error;
    }
  }
  get user() {
    return this._user;
  }
  get sessionToken() {
    return this._sessionToken;
  }
  get clearanceToken() {
    return this._clearanceToken;
  }
  get userAgent() {
    return this._userAgent;
  }
  async initSession() {
    await this.refreshSession();
  }
  async sendMessage(message, opts = {}) {
    const {
      conversationId,
      parentMessageId = v4_default(),
      messageId = v4_default(),
      action = "next",
      timeoutMs,
      onProgress
    } = opts;
    let { abortSignal } = opts;
    let abortController = null;
    if (timeoutMs && !abortSignal) {
      abortController = new AbortController();
      abortSignal = abortController.signal;
    }
    const accessToken = await this.refreshSession();
    const body = {
      action,
      messages: [
        {
          id: messageId,
          role: "user",
          content: {
            content_type: "text",
            parts: [message]
          }
        }
      ],
      model: "text-davinci-002-render",
      parent_message_id: parentMessageId
    };
    if (conversationId) {
      body.conversation_id = conversationId;
    }
    const result = {
      conversationId: conversationId || "",
      messageId,
      response: ""
    };
    const responseP = new Promise((resolve, reject) => {
      const url = `${this._backendApiBaseUrl}/conversation`;
      const headers = {
        ...this._headers,
        Authorization: `Bearer ${accessToken}`,
        Accept: "text/event-stream",
        "Content-Type": "application/json",
        Cookie: `cf_clearance=${this._clearanceToken}`
      };
      if (this._debug) {
        console.log("POST", url, { body, headers });
      }
      fetchSSE({
        url,
        method: "POST",
        headers,
        body: JSON.stringify(body),
        onMessage: (data) => {
          var _a, _b, _c;
          if (data === "[DONE]") {
            return resolve(result);
          }
          try {
            const convoResponseEvent = JSON.parse(data);
            if (convoResponseEvent.conversation_id) {
              result.conversationId = convoResponseEvent.conversation_id;
            }
            if ((_a = convoResponseEvent.message) == null ? void 0 : _a.id) {
              result.messageId = convoResponseEvent.message.id;
            }
            const message2 = convoResponseEvent.message;
            if (message2) {
              let text = (_c = (_b = message2 == null ? void 0 : message2.content) == null ? void 0 : _b.parts) == null ? void 0 : _c[0];
              if (text) {
                result.response = text;
                if (onProgress) {
                  onProgress(result);
                }
              }
            }
          } catch (err) {
            console.warn("fetchSSE onMessage unexpected error", err);
            reject(err);
          }
        }
      }).catch((err) => {
        const errMessageL = err.toString().toLowerCase();
        if (result.response && (errMessageL === "error: typeerror: terminated" || errMessageL === "typeerror: terminated")) {
          return resolve(result);
        } else {
          return reject(err);
        }
      });
    });
    if (timeoutMs) {
      if (abortController) {
        responseP.cancel = () => {
          abortController == null ? void 0 : abortController.abort();
        };
      }
      return pTimeout(responseP, {
        milliseconds: timeoutMs,
        message: "ChatGPT timed out waiting for response"
      });
    } else {
      return responseP;
    }
  }
  async sendModeration(input) {
    const accessToken = await this.refreshSession();
    const url = `${this._backendApiBaseUrl}/moderations`;
    const headers = {
      ...this._headers,
      Authorization: `Bearer ${accessToken}`,
      Accept: "*/*",
      "Content-Type": "application/json",
      Cookie: `cf_clearance=${this._clearanceToken}`
    };
    const body = {
      input,
      model: "text-moderation-playground"
    };
    if (this._debug) {
      console.log("POST", url, headers, body);
    }
    const res = await (0, import_obsidian.requestUrl)({
      url,
      method: "POST",
      headers,
      body: JSON.stringify(body)
    }).then((r) => {
      if (r.status !== 200) {
        const error = new ChatGPTError(`${r.status}`);
        error.response = r;
        error.statusCode = r.status;
        error.statusText = r.text;
        throw error;
      }
      return r.json;
    });
    return res;
  }
  async getIsAuthenticated() {
    try {
      void await this.refreshSession();
      return true;
    } catch (err) {
      return false;
    }
  }
  async refreshSession() {
    const cachedAccessToken = this._accessTokenCache.get(KEY_ACCESS_TOKEN);
    if (cachedAccessToken) {
      return cachedAccessToken;
    }
    let response;
    try {
      const url = `${this._apiBaseUrl}/auth/session`;
      const headers = {
        ...this._headers,
        cookie: `cf_clearance=${this._clearanceToken}; __Secure-next-auth.session-token=${this._sessionToken}`,
        accept: "*/*"
      };
      if (this._debug) {
        console.log("GET", url, headers);
      }
      const res = await (0, import_obsidian.requestUrl)({
        url,
        headers
      }).then((r) => {
        response = r;
        if (r.status !== 200) {
          const error = new ChatGPTError(`${r.status} ${r.text}`);
          error.response = r;
          error.statusCode = r.status;
          error.statusText = r.text;
          throw error;
        }
        return r.json;
      });
      const accessToken = res == null ? void 0 : res.accessToken;
      if (!accessToken) {
        const error = new ChatGPTError("Unauthorized");
        error.response = response;
        error.statusCode = response == null ? void 0 : response.status;
        error.statusText = response == null ? void 0 : response.text;
        throw error;
      }
      const appError = res == null ? void 0 : res.error;
      if (appError) {
        if (appError === "RefreshAccessTokenError") {
          const error = new ChatGPTError("session token may have expired");
          error.response = response;
          error.statusCode = response == null ? void 0 : response.status;
          error.statusText = response == null ? void 0 : response.text;
          throw error;
        } else {
          const error = new ChatGPTError(appError);
          error.response = response;
          error.statusCode = response == null ? void 0 : response.status;
          error.statusText = response == null ? void 0 : response.text;
          throw error;
        }
      }
      if (res.user) {
        this._user = res.user;
      }
      this._accessTokenCache.set(KEY_ACCESS_TOKEN, accessToken);
      return accessToken;
    } catch (err) {
      if (this._debug) {
        console.error(err);
      }
      const error = new ChatGPTError(`ChatGPT failed to refresh auth token. ${err.toString()}`);
      error.response = response;
      error.statusCode = response == null ? void 0 : response.status;
      error.statusText = response == null ? void 0 : response.text;
      error.originalError = err;
      throw error;
    }
  }
  async closeSession() {
    this._accessTokenCache.delete(KEY_ACCESS_TOKEN);
  }
};

// src/settings.ts
var import_obsidian2 = require("obsidian");
var DEFAULT_SETTINGS = {
  userAgent: "",
  clearanceToken: "",
  sessionToken: ""
};
var CanvasConversationSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", {
      text: "Settings for Canvas Conversation Plugin"
    });
    new import_obsidian2.Setting(containerEl).setName("User Agent").setDesc("The user agent to use when making requests - Get from your browser to match clearence token").addText((text) => text.setPlaceholder("User Agent").setValue(this.plugin.settings.userAgent).onChange(async (value) => {
      this.plugin.settings.userAgent = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Clearance Token").setDesc("The clearance token from your browser cookies - cf_clearance").addText((text) => text.setPlaceholder("Clearance Token").setValue(this.plugin.settings.clearanceToken).onChange(async (value) => {
      this.plugin.settings.clearanceToken = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Session Token").setDesc("The session token to use when making requests - __Secure-next-auth.session-token").addText((text) => text.setPlaceholder("Session Token").setValue(this.plugin.settings.sessionToken).onChange(async (value) => {
      this.plugin.settings.sessionToken = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("p", {
      text: "These settings can be taken from your session of ChatGPT."
    });
    containerEl.createEl("p", {
      text: "Open your browser in the ChatGPT page, inspect the page, go to Application and then Cookies, and take the appropiete values."
    });
    containerEl.createEl("p", {
      text: "For the user agent you can take it from any request from the Network tab in the inspector. Or run `navigator.userAgent` in the console."
    });
    containerEl.createEl("p", {
      text: "The tokens refresh every few hours. If you get an error, try refreshing the tokens."
    });
  }
};

// src/canvas-patch.ts
var import_obsidian3 = require("obsidian");
var canvasPrototype;
var originalCanvasOnSelectionContextMenu;
var canvasNodePrototype;
var originalCanvasNodeShowMenu;
function onCanvasMenu(menu) {
  let node = this;
  originalCanvasNodeShowMenu.apply(this, arguments);
  this.canvas.app.workspace.trigger("canvas-conversation:canvas-menu", node, menu);
}
function performCanvasMonkeyPatch(plugin) {
  const view = app.workspace.getActiveViewOfType(import_obsidian3.ItemView);
  checkCanvasMonkeyPatch(view);
  if (!canvasNodePrototype) {
    plugin.registerEvent(plugin.app.workspace.on("active-leaf-change", () => {
      const view2 = app.workspace.getActiveViewOfType(import_obsidian3.ItemView);
      checkCanvasMonkeyPatch(view2);
    }));
  }
}
function checkCanvasMonkeyPatch(view) {
  if ((view == null ? void 0 : view.getViewType()) == "canvas") {
    const canvas = view.canvas;
    if (!canvasPrototype) {
      canvasPrototype = Object.getPrototypeOf(canvas);
      originalCanvasOnSelectionContextMenu = canvasPrototype.onSelectionContextMenu;
      canvasPrototype.onSelectionContextMenu = function(e) {
        let canvas2 = this;
        const originalShowAtMouseEvent = import_obsidian3.Menu.prototype.showAtMouseEvent;
        import_obsidian3.Menu.prototype.showAtMouseEvent = function(e2) {
          const menu = this;
          canvas2.app.workspace.trigger("canvas-conversation:canvas-selection-menu", this.canvas, menu, Array.from(canvas2.selection.values()));
          originalShowAtMouseEvent.apply(this, arguments);
          import_obsidian3.Menu.prototype.showAtMouseEvent = originalShowAtMouseEvent;
          return menu;
        };
        return originalCanvasOnSelectionContextMenu.apply(this, arguments);
      };
    }
    const nodes = canvas.nodes;
    if (nodes.size > 0) {
      const node = nodes.values().next().value;
      const nodePrototype = Object.getPrototypeOf(node);
      if (nodePrototype.showMenu != onCanvasMenu) {
        canvasNodePrototype = nodePrototype;
        originalCanvasNodeShowMenu = nodePrototype.showMenu;
        nodePrototype.showMenu = onCanvasMenu;
      }
    }
  }
}
function removeCanvasMonkeyPatch() {
  if (canvasPrototype) {
    canvasPrototype.onSelectionContextMenu = originalCanvasOnSelectionContextMenu;
    canvasPrototype = null;
  }
  if (canvasNodePrototype) {
    canvasNodePrototype.showMenu = originalCanvasNodeShowMenu;
    canvasNodePrototype = null;
  }
}

// main.ts
var api;
var CanvasConversationPlugin = class extends import_obsidian4.Plugin {
  initGPT() {
    if (!this.settings.clearanceToken || !this.settings.sessionToken || !this.settings.userAgent) {
      return;
    }
    api = new ChatGPTAPI({
      userAgent: this.settings.userAgent,
      clearanceToken: this.settings.clearanceToken,
      sessionToken: this.settings.sessionToken
    });
  }
  async onload() {
    await this.loadSettings();
    this.initGPT();
    this.addSettingTab(new CanvasConversationSettingTab(this.app, this));
    this.registerEvent(this.app.workspace.on("canvas-conversation:canvas-menu", (node, menu) => {
      menu.addSeparator();
      menu.addItem((item) => {
        item.setTitle("Prompt ChatGPT").setIcon("star").onClick(() => onPromptChatGPT(node));
      });
      if (nodeHasMetadata(node)) {
        menu.addItem((item) => {
          item.setTitle("Clean up ChatGPT metadata").setIcon("trash").onClick(() => cleanUpChatGPTMetadata(node));
        });
      }
    }));
    this.registerEvent(this.app.workspace.on("canvas-conversation:canvas-selection-menu", (canvas, menu, nodes) => {
      if (nodes.some((node) => nodeHasMetadata(node))) {
        menu.addSeparator();
        menu.addItem((item) => {
          item.setTitle("Clean up ChatGPT metadata").setIcon("trash").onClick(() => {
            nodes.forEach((node) => {
              cleanUpChatGPTMetadata(node);
            });
          });
        });
      }
    }));
    performCanvasMonkeyPatch(this);
  }
  onunload() {
    removeCanvasMonkeyPatch();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.initGPT();
  }
};
function onPromptChatGPT(node) {
  const text = node.text;
  const canvas = node.canvas;
  if (!api) {
    new import_obsidian4.Notice(`Please configure the plugin.
Go to Settings > Canvas Conversation and fill the fields.`);
    return;
  }
  if (text.includes("AI: true")) {
    new import_obsidian4.Notice(`Cannot prompt AI results.`);
    return;
  }
  let {
    textToPrompt,
    conversationId,
    parentMessageId,
    messageId,
    node: promptNode
  } = preparePrompt(text, node);
  const newNode = createAIResponseNode(canvas, promptNode);
  api.sendMessage(textToPrompt, {
    conversationId,
    parentMessageId,
    messageId
  }).then((response) => {
    onPromptResponse(promptNode, response, messageId, parentMessageId, newNode);
  }).catch((error) => {
    newNode.setText(`Erorr: ${error}`);
    canvas.requestSave();
  });
}
function preparePrompt(text, node) {
  let textToPrompt = text;
  let conversationId, parentMessageId, messageId = v4_default();
  let hasDuplicateHeader = text.includes("*Duplicated node for message tracking*\n");
  if (hasDuplicateHeader) {
    textToPrompt = textToPrompt.replace("*Duplicated node for message tracking*\n", "");
  }
  if (text.includes("^PROMPT BELOW THIS LINE^")) {
    const lines = text.split("\n");
    const conversationIdAndMessageId = lines[hasDuplicateHeader ? 1 : 0];
    const conversationIdAndMessageIdParts = conversationIdAndMessageId.split("|");
    conversationId = conversationIdAndMessageIdParts[0];
    parentMessageId = conversationIdAndMessageIdParts[1];
    textToPrompt = lines.slice(hasDuplicateHeader ? 3 : 2).join("\n");
  }
  if (text.includes("Meta Data - DO NOT DELETE")) {
    conversationId = text.match(/Conversation-Id: (.*)/)[1];
    messageId = v4_default();
    if (text.includes("Parent-Id: ")) {
      parentMessageId = text.match(/Parent-Id: (.*)/)[1];
    }
    const duplicatedNode = node.canvas.createTextNode({ x: node.x + node.width + 32, y: node.y }, { width: node.width, height: node.height }, 1);
    duplicatedNode.setText((hasDuplicateHeader ? "" : "*Duplicated node for message tracking*\n") + node.text.replace(/Message-Id: (.*)/, `Message-Id: ${messageId}`));
    node = duplicatedNode;
    textToPrompt = textToPrompt.substring(0, textToPrompt.indexOf("\n```\nMeta Data - DO NOT DELETE"));
  }
  if (!parentMessageId)
    parentMessageId = v4_default();
  return { textToPrompt, conversationId, parentMessageId, messageId, node };
}
function createAIResponseNode(canvas, prompNode) {
  const node = canvas.createTextNode({
    x: prompNode.x,
    y: prompNode.y + prompNode.height + 32
  }, { width: prompNode.width, height: prompNode.height }, 1);
  node.setText(`Prompting...`);
  canvas.requestSave();
  return node;
}
function onPromptResponse(node, response, messageId, parentMessageId, newNode) {
  if (!node.text.includes("Meta Data - DO NOT DELETE")) {
    node.setText(`${node.text}
\`\`\`
Meta Data - DO NOT DELETE
Conversation-Id: ${response.conversationId}
Message-Id: ${messageId}
Parent-Id: ${parentMessageId}
\`\`\``);
  }
  newNode.setText(`${response.response}
\`\`\`
Meta Data - DO NOT DELETE
Conversation-Id: ${response.conversationId}
Message-Id: ${response.messageId}
Parent-Id: ${messageId}
AI: true
\`\`\``);
  const newPrompt = node.canvas.createTextNode({
    x: newNode.x,
    y: newNode.y + newNode.height + 32
  }, { width: newNode.width, height: newNode.height }, 1);
  newPrompt.setText(`${response.conversationId}|${response.messageId}
^PROMPT BELOW THIS LINE^
`);
  node.canvas.requestSave();
}
function nodeHasMetadata(node) {
  return node.text.includes("Meta Data - DO NOT DELETE") || node.text.includes("^PROMPT BELOW THIS LINE^") || node.text.includes("*Duplicated node for message tracking*");
}
function cleanUpChatGPTMetadata(node) {
  if (node.text.includes("Meta Data - DO NOT DELETE")) {
    const index = node.text.indexOf("\n```\nMeta Data - DO NOT DELETE");
    node.setText(node.text.substring(index, node.text.indexOf("```\n", index + 10)));
  }
  if (node.text.includes("*Duplicated node for message tracking*")) {
    node.setText(node.text.replace(/\*Duplicated node for message tracking\*\n/, ""));
  }
  if (node.text.includes("^PROMPT BELOW THIS LINE^")) {
    node.setText(node.text.substring(node.text.indexOf("^PROMPT BELOW THIS LINE^") + 25));
  }
}
